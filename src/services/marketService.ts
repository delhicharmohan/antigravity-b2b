import { query, getClient } from '../config/db';
import { Totalisator } from '../core/totalisator';
import { emitMarketStatusUpdate } from './socketService';
import { SchedulerService } from './schedulerService';

export const createMarketService = async (
    title: string,
    durationOrTimestamp: number | string,
    initYes: number,
    initNo: number,
    sourceOfTruth: string = 'Generated by AI',
    confidenceScore: number = 0.85,
    resolutionTimestamp?: number | string,
    category: string = 'Other',
    term: string = 'Ultra Short'
) => {
    // ... (existing implementation)
    let closureTime: number;
    let resolutionTime: number;

    if (typeof durationOrTimestamp === 'string' && !isNaN(Number(durationOrTimestamp)) && durationOrTimestamp.length > 10) {
        closureTime = Number(durationOrTimestamp);
    } else if (typeof durationOrTimestamp === 'string') {
        closureTime = new Date(durationOrTimestamp).getTime();
    } else if (typeof durationOrTimestamp === 'number' && durationOrTimestamp > 1000000000000) {
        closureTime = durationOrTimestamp;
    } else {
        closureTime = Date.now() + (Number(durationOrTimestamp) * 1000);
    }

    if (resolutionTimestamp) {
        resolutionTime = typeof resolutionTimestamp === 'string'
            ? new Date(resolutionTimestamp).getTime()
            : resolutionTimestamp;
    } else {
        resolutionTime = closureTime + (30 * 60 * 1000);
    }

    const result = await query(
        `INSERT INTO markets (title, status, closure_timestamp, resolution_timestamp, pool_yes, pool_no, source_of_truth, confidence_score, category, term) 
         VALUES ($1, 'OPEN', $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *`,
        [title, closureTime, resolutionTime, initYes || 0, initNo || 0, sourceOfTruth, confidenceScore, category, term]
    );

    const newMarket = result.rows[0];

    // Audit Trail: Create wagers for initial liquidity if they exist
    if (initYes > 0 || initNo > 0) {
        try {
            // 1. Get or create System Merchant (Safely handle concurrency)
            let systemMerchantRes = await query(
                `INSERT INTO merchants (api_key_hash, raw_api_key, config) 
                 VALUES ('system_liquidity_hash', 'system_liquidity_key', $1)
                 ON CONFLICT (api_key_hash) DO UPDATE SET config = excluded.config
                 RETURNING id`,
                [JSON.stringify({ name: 'System Liquidity', default_rake: 0 })]
            );
            const systemMerchantId = systemMerchantRes.rows[0].id;

            // 2. Create the wagers
            if (initYes > 0) {
                await query(
                    "INSERT INTO wagers (merchant_id, market_id, selection, stake, status) VALUES ($1, $2, $3, $4, $5)",
                    [systemMerchantId, newMarket.id, 'yes', initYes, 'ACCEPTED']
                );
            }
            if (initNo > 0) {
                await query(
                    "INSERT INTO wagers (merchant_id, market_id, selection, stake, status) VALUES ($1, $2, $3, $4, $5)",
                    [systemMerchantId, newMarket.id, 'no', initNo, 'ACCEPTED']
                );
            }
        } catch (auditError) {
            console.error('[MarketService] Failed to create audit wagers:', auditError);
            // We don't fail the whole market creation, but we log it
        }
    }

    // Automatically register event-driven jobs
    SchedulerService.scheduleMarketJobs(newMarket);

    return newMarket;
};

export const settleMarket = async (marketId: string, outcome: 'yes' | 'no') => {
    const client = await getClient();

    try {
        await client.query('BEGIN');

        // 1. Lock and get market
        const marketRes = await client.query('SELECT * FROM markets WHERE id = $1 FOR UPDATE', [marketId]);
        if (marketRes.rows.length === 0) throw new Error('Market not found');
        const market = marketRes.rows[0];

        if (market.status === 'SETTLED') {
            await client.query('ROLLBACK');
            client.release();
            return { success: true, message: 'Market already settled' } as any;
        }

        const poolData = {
            yes: Number(market.pool_yes),
            no: Number(market.pool_no)
        };

        // 2. Fetch all wagers for this market
        const wagersRes = await client.query('SELECT * FROM wagers WHERE market_id = $1', [marketId]);
        const wagers = wagersRes.rows;

        // Optimization: Bulk fetch merchant configs to avoid N+1
        const uniqueMerchantIds = [...new Set(wagers.map((w: any) => w.merchant_id))];
        const merchantConfigsRes = await client.query(
            'SELECT id, config FROM merchants WHERE id = ANY($1)',
            [uniqueMerchantIds]
        );
        const merchantRakeMap = new Map<string, number>();
        for (const row of merchantConfigsRes.rows) {
            merchantRakeMap.set(row.id, row.config?.default_rake);
        }

        // 3. Calculate and update payouts
        let totalPayoutsCalculated = 0;

        for (const wager of wagers) {
            let payout = 0;
            if (wager.selection === outcome) {
                // Fetch merchant rake
                const rake = merchantRakeMap.get(wager.merchant_id);

                payout = Totalisator.calculatePotentialPayout(Number(wager.stake), poolData, outcome, rake);
                totalPayoutsCalculated += payout;
            }

            await client.query(
                'UPDATE wagers SET payout = $1, status = $2, settled_at = NOW() WHERE id = $3',
                [payout, 'SETTLED', wager.id]
            );
        }

        // --- Post-Calculation Sanity Check ---
        const totalPoolCollected = poolData.yes + poolData.no;
        if (totalPayoutsCalculated > totalPoolCollected + 0.01) { // 0.01 buffer for tiny float diffs
            throw new Error(`Solvency Alert: Calculated payouts ($${totalPayoutsCalculated}) exceed total pool ($${totalPoolCollected}). Settlement aborted.`);
        }

        // 4. Update market status
        await client.query(
            'UPDATE markets SET status = $1, outcome = $2 WHERE id = $3',
            ['SETTLED', outcome, marketId]
        );

        await client.query('COMMIT');

        const { LoggerService } = await import('./loggerService');
        await LoggerService.info(`[Settlement] ✅ Market ${marketId} settled as ${outcome.toUpperCase()}`, {
            marketId,
            outcome,
            wagerCount: wagers.length,
            poolYes: poolData.yes,
            poolNo: poolData.no
        });

        emitMarketStatusUpdate(marketId, 'SETTLED');

        // 5. Trigger Webhook Notifications for involved merchants
        const { WebhookService } = await import('./webhookService');
        const finalWagersRes = await client.query('SELECT * FROM wagers WHERE market_id = $1', [marketId]);
        const finalWagers = finalWagersRes.rows;

        const uniqueMerchants = [...new Set(finalWagers.map(w => w.merchant_id))];
        for (const merchantId of uniqueMerchants) {
            const merchantWagers = finalWagers.filter(w => w.merchant_id === merchantId);
            WebhookService.notifySettlement(merchantId, marketId, 'SETTLED', outcome, merchantWagers);
        }

        return { success: true, wagerCount: wagers.length };
    } catch (e: any) {
        await client.query('ROLLBACK');
        const { LoggerService } = await import('./loggerService');
        await LoggerService.error(`[Settlement] ❌ Settlement failed for Market ${marketId}: ${e.message}`, {
            marketId,
            error: e.message,
            stack: e.stack
        });
        throw e;
    } finally {
        client.release();
    }
};

export const voidMarket = async (marketId: string) => {
    const client = await getClient();

    try {
        await client.query('BEGIN');

        // 1. Lock and get market
        const marketRes = await client.query('SELECT * FROM markets WHERE id = $1 FOR UPDATE', [marketId]);
        if (marketRes.rows.length === 0) throw new Error('Market not found');
        const market = marketRes.rows[0];

        if (market.status === 'SETTLED' || market.status === 'VOID') {
            throw new Error(`Market already ${market.status.toLowerCase()}`);
        }

        // 2. Fetch all wagers for this market
        const wagersRes = await client.query('SELECT * FROM wagers WHERE market_id = $1', [marketId]);
        const wagers = wagersRes.rows;

        // 3. Refund all wagers
        for (const wager of wagers) {
            await client.query(
                'UPDATE wagers SET payout = $1, status = $2, settled_at = NOW() WHERE id = $3',
                [Number(wager.stake), 'VOIDED', wager.id]
            );
        }

        // 4. Update market status
        await client.query(
            'UPDATE markets SET status = $1 WHERE id = $2',
            ['VOIDED', marketId]
        );

        await client.query('COMMIT');

        const { LoggerService } = await import('./loggerService');
        await LoggerService.warn(`[Void] ⚠️ Market ${marketId} voided and ${wagers.length} wagers refunded`, {
            marketId,
            wagerCount: wagers.length
        });

        emitMarketStatusUpdate(marketId, 'VOIDED');

        return { success: true, wagerCount: wagers.length };
    } catch (e: any) {
        await client.query('ROLLBACK');
        const { LoggerService } = await import('./loggerService');
        await LoggerService.error(`[Void] ❌ Void failed for Market ${marketId}: ${e.message}`, {
            marketId,
            error: e.message
        });
        throw e;
    } finally {
        client.release();
    }
};
